---
title: 文件操作
date: 2023-07-21 20:29:19
tags:
  - C
---

包含文件操作、宏、声明等等

<!--more-->

## 宏和声明

- 预编译指令
  - `#` 开头是预编译指令
  - 不是 C 语言的成分，但 C 语言离不开他们
  - `#define`来定义一个宏：`#define PI 3.14` 不能加分号，因为不是 C 语言的语句
  - 预定义宏：
    - `__LINE__`
    - `__FILE__`
    - `__DATE__`
    - `__TIME__`
    - `__STDC__`
  - 带参数的宏：所有用到参数的地方都要带括号提高优先级
  ```C
    #define RADTODEG(x) ((x)*3.14)
  ```
- 多个.c 文件的情况：
  - `main()` 里面的代码太长了，适合分成多个文件
  - 一个源码文件太长适合分成多个文件
  - 两个独立的源码文件不能编译成可执行文件
- 头文件：
  - 把函数原型放到一个头文件（以.h 结尾）中，在需要调用这个函数的原代码文件（.c 文件）中 #include 这个头文件，就能让编译器在编译的时候知道函数原型。
  - #include 有两种形式指出要插入的文件
    - `" "`要求编译器首先在当前目录（.c 所在目录）寻找这个文件，如果没有，到编译器指定的目录去找
    - `<>` 让编译器只在指定的目录下找:编译器自己知道自己的标准库的头文件在哪
    - 环境变量和编译器命令行参数也可以指定寻找头文件的目录
- `#include` 误区：
  - `#include` 不是用来引入库的
  - `stdion.h` 只有 `printf` 原型，`printf`的代码再另外的地方--某个`lib(Windows)`或`a(Unix)`中。
  - 现在 C 的编译器默认会映入所有的标准库
  - `#include <stdio.h>` 只是为了让编译器知道`printf`的函数原型，保证调用时给出的参数值是正确的类型
- 声明 `extern int i;`
  - 声明是不会产生代码的东西
    - `函数原型`
    - `变量声明`
    - `结构声明`
    - `宏声明`
    - `枚举声明`
    - `类型声明`
    - `inline 函数`
  - 定义是会产生代码的东西
  - 只有声明可以放在头文件中，否则会造成一个项目多个编译单元有重名的实体
- 标准头文件结构(解决宏重复定义)
  ```C
    #ifndef _MAX_H
    #define _MAX_H
    ....
    #endif
  ```

## 文件的输入和输出

- 用 `>` 和 `<` 做重定向：`<` 指定一个文件作为输入，`>` 指定一个文件写入
- `FILE* fopen(const char* restrict path, const char* restrict mode);`
- `int fclose(FILE *stream);`
- `fscanf(FILE*, ...)`
- `fprintf(FILE*, ...)`

  ```C
    FILE* fp = fopen("file", "r");
    if(fp){
      fscanf(fp, ...);
      fclose(fp);
    }else{
      ...
    }
  ```

  - fopen

    | 参数 | 含义                                               |
    | ---- | -------------------------------------------------- |
    | r    | 打开只读                                           |
    | r+   | 打开读写，从文件头开始                             |
    | w    | 打开只写。如果不存在则新建，如果存在则清空         |
    | w+   | 打开读写。如果不存在则新建，如果存在则清空         |
    | a    | 打开追加。如果不存在则新建，如果存在则从文件尾开写 |
    | ..x  | 只新建，如果文件已存在，则不能打开                 |

- 二进制文件

  - 其实所有文件最终都是二进制
  - 文本文件无非是最简单的方式可以读写的文件
    - more、tail
    - cat
    - vi
  - 而二进制文件是需要专门的程序来读写的问间
  - 文本文件的输入输出时格式化，可能经过转码
  - size_t fread(void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);
  - size_t fwrite(const void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);
  - 返回成功读写的字节数

- 按位运算

  - &：按位取与
    - 两个数都是 1，则为 1
    - 应用：
      - 让某一位或某些位置零：x & 0xFE
      - 取一个数中的一段：x & 0xFF
  - |：按位取或
    - 有 1 则 1
    - 应用：
      - 使一位或几位为 1：x | 0x01
      - 把两个数拼起来：0x00FF | 0xFF00
  - ~：按位取反
    - 把 1 变成 0, 0 变成 1
    - 应用：
      - 想要得到全部位为 1 的数：~0
      - 7 的二进制是 0111，x | 7 使得低 3 位为 1，而 x & ~7，就使得低 3 位为 0；
  - ^：按位的异或
    - 两位相同结果为 0，不同为 1
    - 应用：
      - 如果 x 和 y 相等，那么 x^y 的结果是 0；
      - 对于一个变量做两次异或相当于什么都没做：
        - x ^ y ^ x ==> y
  - <<：左移
    - i << j：i 中所有位想左移动 j 个位置，而右边填入 0；
    - 所有小于 int 的类型，移位以 int 方式来做结果还是 int：
      - x << 1 等价于 x \*= 2;
      - x << n 等价于 x \*= $2^n$;
  - \>>：右移
    - i 中所有的位向右移 j 位
    - 所有小于 int 的类型，移位以 int 的方式来做，结果是 int
    - 对于 unsigned 类型，左边填入 0；
    - 对于 signed 的类型，左边填入原来最高位(保持符号不变)
      - x >> 1 等价于 x /=2;
      - x >> n 等价于 x /= $2^n$

- 位段：把一个 int 的若干位组合成一个结构

  ```C
    struct {
        unsigned int leading : 3;
        unsigned int FLAG1 : 1;
        unsigned int FLAG2 : 1;
        int trailing : 11;
    };
  ```

  - 可以直接用位段的成员名称来访问
    - 比位、与、或方便
    - 编译器会安排其中的位的排列，不具有可移植性
    - 当所需的位超过一个 int 时会采用多个 int
