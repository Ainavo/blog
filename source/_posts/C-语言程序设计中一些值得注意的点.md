---
title: C 语言程序设计中一些值得注意的点
date: 2023-07-15 13:14:46
tags:
  - C
---

_Notes_:参考课程[<<浙大瓮恺 C 语言程序设计>>](https://space.bilibili.com/1355742754)

<!--more-->

- scanf() 中格式字符中的字符是必须输入的：
  ```C
      scanf("print %d", &a) //终端中输入必须是 "print xxx"
  ```
- 运算符和算子
  ```C
    a = b + c // a, b, c 算子； =, + 运算符；
  ```
- 运算符优先级
  | 优先级 | 运算符 | 运算 | 结合关系 | 示例 |
  | ---- | ---- | ---- | ---- | ---- |
  | 1 | + | 单目不变 | 自右向左 | a*+b |
  | 1 | - | 单目取负 | 自右向左 | a*-b |
  | 2 | \* | 乘 | 自左向右 | a\*b |
  | 2 | / | 除 | 自左向右 | a/b |
  | 2 | % | 取余 | 自左向右 | a%b |
  | 3 | + | 加 | 自左向右 | a+b |
  | 3 | - | 减 | 自左向右 | a-b |
  | 4 | = | 赋值 | 自右向左 | a=b|

- a++ 和 ++a
  ```C
    ++1; // 返回结果 2；并实现 +1 功能；
    1++; // 返回结果 1；并实现 +1 功能；
  ```
- 循环 tips：
  - 如果有固定次数，用 for 循环： for(; ; ;)
  - 如果必须执行一次：用 do_while 循环
  - 其他情况用 while 循环
- 跳出循环：
  - break：跳出循环
  - continue：跳出本轮循环，继续下一轮
  - goto：
    ```C
        ....
        goto out:
    out:
        return 0;
    ```
- 辗转相除法：

  ```C
    // 如果b等于0，计算结束，a就是最大公约数；
    // 否则，计算a除以b的余数，让a等于b，b等于那个余数；
    // 构建循环体。
    #include <stdio.h>

    int main(){
        int a, b;
        int temp;
        scanf("%d %d", &a, &b);
        while(b != 0){
            temp = a % b;
            a = b;
            b = temp;
            printf("a=%d, b=%d, temp=%d\n", a, b, temp);
        };
        printf("a与b的最大公约数为 %d", a);
        return 0;
    }
  ```

- 数字类型

  - 类型名称：int、long、double
  - 输入输出时的格式化：%d、%ld、%lf
  - 所表达数的范围：char < short < int < float < double
  - 内存中所占据的大小：1 个字节到 16 个字节
  - 内存中的表达形式：二进制数（补码）、编码

- sizeof：一个 int 表达一个寄存器的大小
  ```C
  #include<stdio.h>
  int main(){
    printf("sizeof(char) = %ld\n", sizeof(char)); // 1字节（8比特）
    printf("sizeof(short) = %ld\n", sizeof(short)); // 2字节
    printf("sizeof(int) = %ld\n", sizeof(int)); // 取决于编译器（CPU）
    printf("sizeof(long) = %ld\n", sizeof(long)); // 取决于编译器（CPU）
    printf("sizeof(long long) = %ld\n", sizeof(long long)); // 8字节
    return 0;
  }
  ```
- 补码的意义：补码和原码相加可以得到一个溢出的 0
- 整数的范围：对于一个字节（8 位）可以表达的是：

  - 00000000~11111111
  - 11111111~10000000-->-1~-128(作为补码来看)
  - 00000001~01111111--> 1~127

  ```C
    #include<stdio.h>

    int main(){
        char c = 255;
        int i = 255;
        printf("c=%d, i=%d\n", c, i); // c=-1, i=255
        // 11111111
        // 00000000 00000000 00000000 11111111
        return 0;
    }
  ```

  - char(1 字节):-128~127
  - short(2):-32768~32767
  - int:取决于编译器（CPU），通常意义上是"1 个字" $-2^{32}-1$ ~ $2^{32-1}-1$
  - long(4 字节)
  - long long(8 字节)

- unsigned:表示纯二进制(主要为了做移位)

  ```C
     #include<stdio.h>

      int main(){
          unsigned char a = 255;
          int i =255;
          printf("c=%d, i=%d\n", c, i);
          // 00000000 - 11111111 0~255 正常：-128~127
          // 00000000 00000000 00000000 11111111
          return 0;
      }
  ```

- 整数输入输出：int 和 long long

  - %d:int
  - %u:unsigned
  - %ld:long long
  - %lu: unsigned long long

- 浮点数类型：
  | 类型 | 字长 | 范围 | 有效数字 | scanf | printf |
  | ---- | ---- | ---- | ---- | ---- | ---- |
  | float | 32 | ±(1.2x $10^{-38}$~3.40x$10^{38}$), 0, ±inf, nan| 7 | %f |%f, %e(科学计数) |
  | double | 64 | ±(2.2x $10^{-308}$~1.79x$10^{308}$), 0, ±inf, nan | 15 | %lf | %f, %e(科学计数) |

- 超过范围的浮点数：
  - printf 输出 inf 表示无穷大
  - printf 输出 nan 表示不存在的浮点数
- 浮点运算的精度
  - 带小数点的字面量意思是 double 而非 float
  - float 需要用 f 或 F 后缀来表明身份
    ```C
        float a, b, c;
        a = 1.345f;
        b = 1.123f;
        c = a + b;
        if (c == 2.468)
            printf("相等\n");
        else
            printf("不相等！c=%.10f, 或%f\n", c, c)  // f1 == f2 可能失败 ； fabs(f1-f2) < 1e-12 验证;
    ```
- 浮点数的内部表达：

  - sign(1 bit)：符号位
  - exponent(11 bit)：指数位
  - fraction(52 bit)：小数位

- 字符类型
  - char(字符)：printf 和 scanf 用%c 输入输出
    ```C
        int main(){
            char a;
            a = '1';
            printf("c=%d", a);  // 1;
            printf("c=%c", a);  // 49 ASIIC 码
        }
    ```
- 逃逸字符：用来表达无法打印出来的控制字符或者特殊字符，他由一个反斜杠"\"开头，后面跟上另一个字符，这两个字符合起来，组成一个字符。
  | 字符 | 意义 | 字符 | 意义 |
  | ---- | ---- | ---- | ---- |
  | \b | 回退一格 | \" | 双引号 |
  | \t | 到下一个表格位 | \' | 单引号 |
  | \n | 换行 | \\ | 反斜杠本身 |
  | \r | 回车 | | |
- 自动类型转换：
  - 当运算符两边出现不一样类型时，会自动转换成较大（范围大）的类型；
  - char-->short-->int-->long-->long long
  - int-->float-->double
  - 注：
    - 对于 printf，任何小于 int 类型的都会转换成 int；float 会被转换成 double；
    - 对于 scanf 则不会，要输入 short，需要 %hd
- 强制转换：优先级高于四则运算
  - (类型)值
    ```C
    (int)32.3
    (short)32
    ```
  - 注意小的变量不总能表达大的变量
- 逻辑类型(bool)和逻辑运算
  | 运算符 | 描述 | 示例 | 结果 |
  | ---- | ---- | ---- | ---- |
  | ! | 逻辑非 | !a | 如果 a 是 true 结果就是 false；如果 a 是 false，结果就是 true； |
  | && | 逻辑与 | a && b | 如果 a 和 b 都是 true，结果就是 true；否则就是 false； |
  | \|\| | 逻辑或 | a || b | 如果 a 和 b 中有一个是 true，结果为 true；两个都为 false，结果为 false； |
- 运算符优先级
  | 优先级 | 运算符 | 结合性 |
  | ---- | ---- | ---- |
  | 1 | （） | 从左到右 |
  | 2 | ! + - ++ -- | 从右到左（单目的+和-） |
  | 3 | _ / % | 从左到右 |
  | 4 | + - | 从左到右 |
  | 5 | <<= >>= | 从左到右 |
  | 6 | == != | 从左到右 |
  | 7 | && | 从左到右 |
  | 8 | \|\| | 从左到右 |
  | 9 | = += -= _= /= %=| 从左到右 |
- 条件运算符：自右向左
  ```c
    m<n ?  a:a+5 // (条件) ? a : b
  ```
- 逗号运算符：所有运算符中优先级最低的
  ```C
    for(i=0, j=10; i<j; i++, j--) // 基本上只有 for 条件会用到
  ```
- 本地变量
  - 生存期：什么时候这个变量出现了，到什么时候它消亡了
  - 作用域：在代码什么范围内可以访问这个变量（这个变量起作用）
  - 对于本地变量，这两个问题答案是统一的：大括号内--块
    - 程序运行进入这个块之前，其中的变量不存在，离开这个块，其中的变量就消失了
    - 块外面定义的变量在里面仍然有效
    - 快里面定义了和外面同名的变量则掩盖了外面的
    - 不能在一 个块中定义同名变量
- 函数声明：
  ```C
      void swap(double a, double b); // 与函数名称相同
      void swap(void)  // 无参数
  ```
- 数组的定义
  - <类型> 变量名[元素数量]；
  - int grades[100];
  - double weight[20];
- 元素必须是整数；
  - 数组：是一种容器(存放东西的东西)
  - 其中所有元素都具有相同的数据类型；
  - 一旦创建，不能改变大小；
  - \*(数组中元素在内存中是连续依次排列的) -数组初始化：

```C
   int a[] = {1, 2, 3};
```

- C99 中支持：

```C
    int a[10] = {[0] = 2, [2] = 3, 6};
```

- 用[n]在初始化数据中给出定位
- 没有定位的数据接在前面的位置后面，其余位置自动补零
- 也可以不给出数组大小，让编译器算
- 适合初始数据稀疏的数组

- 数组的大小：sizeof(a)/sizeof(a[0])
- 数组的赋值：
  ```C
      int a[] = {1, 2, 3,};
      int b[] = a; // error
  ```
  - 数组不能直接赋值
  - 把一个数组元素交给另一个数组，必须采用遍历
- 数组作为函数的参数时：
  - 数组作为函数参数，往往必须再用另一个参数来传入数组的长度
  - 不能在 a[] 中 [] 给出数组大小
  - 不能利用 sizeof 计算元素个数
- 二维数组：
  - a[i][j]是一个 int：表示第 i 行第 j 列
  - a[i, j]错误表达：表示 a[j] ("**,**"运算符)
  - 列数必须有，行数可以省略
- 运算符 &
  - scanf("%d, &d)中&：获取变量的地址
  - &(a+b), &(a++), &(++a) 都会报错， &右边只能是固定数
- 指针：就是保存地址的变量
  ```C
    int i;
    int* p = &1;
    int* p, q;  // p是一个指针，指向int 同下；q不是一个指针；
    int *p, q; // 同上
  ```
- 指针作为参数：
  ```C
    void f(int *p);
    int main(){
        int i = 6;
        f(&i);
    }
  ```
- 访问地址变量\*：
  - \*是一个单目运算符，用来访问指针的值表示的地址上的变量
  - 可以作为左值或右值：
    - int k = \*p
    - \*p = k+1
- 指针应用场景：
  - 交换两个值
  - 函数返回运算状态，结果通过指针返回
- 指针最常见错误：指针未指向地址，就赋值
- 以下四种函数原型是等价的：
  - int sum(int \*ar, int n);
  - int sum(int \*, int);
  - int sum(int ar[], int n);
  - int sum(int[], int);
- 数组变量就是特殊的指针：
  - 数组变量本身表达地址：
    - int a[10]; int\*p = a; //无需用&取地址
    - 但是数组的单元表达的是变量，需要用&去取地址
    - a == &a[0]
  - [] 运算符可以对数组做，也可以对指针做：
    - p[0]<==>a[0]
  - \*运算符可以对指针做，也可以对数组做：
    - \*a = 25;
  - 数组变量是 const 指针：
    ```C
    int a[] <==> int * const a // 因此两个数组间不能直接赋值
    ```
- 指针与 const：
  - 指针是 const：表示一旦得到了某个变量的地址，不能再指向其他变量：
    ```C
    int *const q = &i; // q 是 const
    *q = 26； // OK
    q++; // error
    ```
  - 所指是 const：表示不能通过这个指针去修改那个变量（并不能使得那个变量成为 const）
  ```C
    const int*p = &i;
    *p = 26; //EEROR! (*p)是const
    i = 26; //OK
    p = &j; //OK
    // i 可以变；p 可以变；*p 不可以变；
  ```
  - 例子：判断 const 和*的位置关系--const 在\*前 *p 不能被修改；const 在\*后 p(地址不能被修改)
  ```C
    int i;
    const int* p1 = &i;
    int const* p2 = &i;
    int *const p3 = &i;
    // 技巧：主要看 const 修饰的是 *p，还是 p
  ```
